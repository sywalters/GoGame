<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>9x9 Go Game vs AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .board {
            background-color: #DCB35C;
            position: relative;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            gap: 1px;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .intersection {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            aspect-ratio: 1/1;
        }
        
        .intersection::before, .intersection::after {
            content: '';
            position: absolute;
            background-color: #000;
        }
        
        .intersection::before {
            width: 100%;
            height: 1px;
        }
        
        .intersection::after {
            width: 1px;
            height: 100%;
        }
        
        .stone {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            position: relative;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
        }
        
        .white {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
        }
        
        .last-move {
            box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.8);
        }
        
        .star-point {
            width: 8px;
            height: 8px;
            background-color: #000;
            border-radius: 50%;
            position: absolute;
            z-index: 5;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .stone-placed {
            animation: fadeIn 0.3s ease-out;
        }
        
        .score-display {
            transition: all 0.3s ease;
        }
        
        .hover-preview {
            opacity: 0.5;
            transform: scale(0.9);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center py-8">
    <div class="max-w-4xl w-full px-4">
        <h1 class="text-3xl font-bold text-center mb-6 text-gray-800">Go Game (9x9)</h1>
        
        <div class="flex flex-col md:flex-row gap-6 items-center md:items-start">
            <!-- Game board -->
            <div class="board w-full max-w-md aspect-square" id="board">
                <!-- Board will be generated by JavaScript -->
            </div>
            
            <!-- Game controls and info -->
            <div class="w-full md:w-64 bg-white p-4 rounded-lg shadow-md">
                <div class="flex justify-between items-center mb-4">
                    <div class="text-lg font-semibold">Game Info</div>
                    <button id="new-game" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm">
                        <i class="fas fa-sync-alt mr-1"></i> New Game
                    </button>
                </div>
                
                <div class="space-y-4">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center">
                            <div class="stone black w-5 h-5 mr-2"></div>
                            <span>Black (You)</span>
                        </div>
                        <span id="black-captures" class="font-bold">0</span>
                    </div>
                    
                    <div class="flex items-center justify-between">
                        <div class="flex items-center">
                            <div class="stone white w-5 h-5 mr-2"></div>
                            <span>White (AI)</span>
                        </div>
                        <span id="white-captures" class="font-bold">0</span>
                    </div>
                    
                    <div class="bg-gray-100 p-3 rounded">
                        <div class="text-sm font-medium mb-1">Current Turn:</div>
                        <div id="current-turn" class="text-lg font-bold flex items-center">
                            <div class="stone black w-6 h-6 mr-2"></div>
                            <span>Black's turn</span>
                        </div>
                    </div>
                    
                    <div id="game-status" class="text-center py-2 px-3 bg-yellow-100 text-yellow-800 rounded text-sm hidden">
                        Game in progress
                    </div>
                    
                    <button id="pass-turn" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-800 py-2 rounded flex items-center justify-center">
                        <i class="fas fa-forward mr-2"></i> Pass
                    </button>
                    
                    <button id="resign" class="w-full bg-red-100 hover:bg-red-200 text-red-800 py-2 rounded flex items-center justify-center">
                        <i class="fas fa-flag mr-2"></i> Resign
                    </button>
                </div>
            </div>
        </div>
        
        <div class="mt-6 bg-white p-4 rounded-lg shadow-md w-full">
            <h2 class="text-xl font-semibold mb-3">How to Play</h2>
            <ul class="list-disc pl-5 space-y-1 text-sm text-gray-700">
                <li>Black plays first, then players alternate turns</li>
                <li>Place stones on intersections to surround territory</li>
                <li>Stones are captured when completely surrounded</li>
                <li>The player with more territory at the end wins</li>
                <li>Pass when you have no beneficial moves left</li>
            </ul>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const boardSize = 9;
            let board = Array(boardSize).fill().map(() => Array(boardSize).fill(null));
            let currentPlayer = 'black';
            let lastMove = null;
            let gameOver = false;
            let blackCaptures = 0;
            let whiteCaptures = 0;
            let koProtection = null;
            
            // DOM elements
            const boardElement = document.getElementById('board');
            const currentTurnElement = document.getElementById('current-turn');
            const blackCapturesElement = document.getElementById('black-captures');
            const whiteCapturesElement = document.getElementById('white-captures');
            const gameStatusElement = document.getElementById('game-status');
            const newGameButton = document.getElementById('new-game');
            const passTurnButton = document.getElementById('pass-turn');
            const resignButton = document.getElementById('resign');
            
            // Initialize the board
            function initializeBoard() {
                boardElement.innerHTML = '';
                
                // Create intersections
                for (let y = 0; y < boardSize; y++) {
                    for (let x = 0; x < boardSize; x++) {
                        const intersection = document.createElement('div');
                        intersection.className = 'intersection';
                        intersection.dataset.x = x;
                        intersection.dataset.y = y;
                        
                        // Add star points (hoshi)
                        if ((x === 2 || x === 6) && (y === 2 || y === 6)) {
                            const starPoint = document.createElement('div');
                            starPoint.className = 'star-point';
                            intersection.appendChild(starPoint);
                        } else if (x === 4 && y === 4) {
                            const starPoint = document.createElement('div');
                            starPoint.className = 'star-point';
                            intersection.appendChild(starPoint);
                        }
                        
                        intersection.addEventListener('click', () => handleMove(x, y));
                        intersection.addEventListener('mouseenter', () => showPreview(x, y));
                        intersection.addEventListener('mouseleave', () => hidePreview());
                        
                        boardElement.appendChild(intersection);
                    }
                }
            }
            
            // Show stone placement preview
            function showPreview(x, y) {
                if (gameOver || board[y][x] !== null) return;
                
                hidePreview(); // Clear any existing preview
                
                const intersection = document.querySelector(`.intersection[data-x="${x}"][data-y="${y}"]`);
                const previewStone = document.createElement('div');
                previewStone.className = `stone ${currentPlayer} hover-preview`;
                intersection.appendChild(previewStone);
                intersection.dataset.preview = 'true';
            }
            
            // Hide stone placement preview
            function hidePreview() {
                const previews = document.querySelectorAll('[data-preview="true"]');
                previews.forEach(el => {
                    const previewStone = el.querySelector('.stone.hover-preview');
                    if (previewStone) el.removeChild(previewStone);
                    delete el.dataset.preview;
                });
            }
            
            // Handle a move
            function handleMove(x, y) {
                if (gameOver || board[y][x] !== null) return;
                
                // Check for ko rule violation
                if (koProtection && koProtection.x === x && koProtection.y === y) {
                    showMessage("Ko rule: You can't retake immediately");
                    return;
                }
                
                // Make a copy of the board for testing
                const testBoard = board.map(row => [...row]);
                testBoard[y][x] = currentPlayer;
                
                // Check for suicide move
                const group = findGroup(testBoard, x, y);
                if (!hasLiberties(testBoard, group)) {
                    showMessage("Invalid move: Suicide not allowed");
                    return;
                }
                
                // Place the stone
                placeStone(x, y, currentPlayer);
                
                // Check for captures
                const oppositePlayer = currentPlayer === 'black' ? 'white' : 'black';
                const capturedStones = checkCaptures(testBoard, oppositePlayer);
                
                // Update captures count
                if (capturedStones.length > 0) {
                    if (currentPlayer === 'black') {
                        blackCaptures += capturedStones.length;
                        blackCapturesElement.textContent = blackCaptures;
                    } else {
                        whiteCaptures += capturedStones.length;
                        whiteCapturesElement.textContent = whiteCaptures;
                    }
                    
                    // Remove captured stones
                    capturedStones.forEach(stone => {
                        board[stone.y][stone.x] = null;
                        updateIntersection(stone.x, stone.y);
                    });
                    
                    // Set ko protection if exactly one stone was captured
                    if (capturedStones.length === 1) {
                        koProtection = { x: capturedStones[0].x, y: capturedStones[0].y };
                    } else {
                        koProtection = null;
                    }
                } else {
                    koProtection = null;
                }
                
                lastMove = { x, y };
                updateLastMoveMarker();
                
                // Switch turns
                currentPlayer = oppositePlayer;
                updateTurnDisplay();
                
                // AI move (if it's white's turn)
                if (currentPlayer === 'white' && !gameOver) {
                    setTimeout(makeAIMove, 800);
                }
            }
            
            // Place a stone on the board
            function placeStone(x, y, color) {
                board[y][x] = color;
                updateIntersection(x, y);
            }
            
            // Update the visual representation of an intersection
            function updateIntersection(x, y) {
                const intersection = document.querySelector(`.intersection[data-x="${x}"][data-y="${y}"]`);
                intersection.innerHTML = '';
                
                // Re-add star point if needed
                if ((x === 2 || x === 6) && (y === 2 || y === 6)) {
                    const starPoint = document.createElement('div');
                    starPoint.className = 'star-point';
                    intersection.appendChild(starPoint);
                } else if (x === 4 && y === 4) {
                    const starPoint = document.createElement('div');
                    starPoint.className = 'star-point';
                    intersection.appendChild(starPoint);
                }
                
                if (board[y][x]) {
                    const stone = document.createElement('div');
                    stone.className = `stone ${board[y][x]} stone-placed`;
                    intersection.appendChild(stone);
                }
            }
            
            // Update the last move marker
            function updateLastMoveMarker() {
                // Remove all last move markers
                document.querySelectorAll('.last-move').forEach(el => {
                    el.classList.remove('last-move');
                });
                
                if (lastMove) {
                    const intersection = document.querySelector(`.intersection[data-x="${lastMove.x}"][data-y="${lastMove.y}"]`);
                    if (intersection) {
                        intersection.classList.add('last-move');
                    }
                }
            }
            
            // Update the turn display
            function updateTurnDisplay() {
                if (currentPlayer === 'black') {
                    currentTurnElement.innerHTML = `
                        <div class="stone black w-6 h-6 mr-2"></div>
                        <span>Black's turn</span>
                    `;
                } else {
                    currentTurnElement.innerHTML = `
                        <div class="stone white w-6 h-6 mr-2"></div>
                        <span>White's turn</span>
                    `;
                }
            }
            
            // Check for captures after a move
            function checkCaptures(testBoard, color) {
                const captured = [];
                
                // Check all groups of the opposite color
                const visited = Array(boardSize).fill().map(() => Array(boardSize).fill(false));
                
                for (let y = 0; y < boardSize; y++) {
                    for (let x = 0; x < boardSize; x++) {
                        if (testBoard[y][x] === color && !visited[y][x]) {
                            const group = findGroup(testBoard, x, y, visited);
                            if (!hasLiberties(testBoard, group)) {
                                captured.push(...group);
                            }
                        }
                    }
                }
                
                return captured;
            }
            
            // Find all connected stones of the same color
            function findGroup(testBoard, x, y, visited = null) {
                if (!visited) {
                    visited = Array(boardSize).fill().map(() => Array(boardSize).fill(false));
                }
                
                const color = testBoard[y][x];
                if (color === null) return [];
                
                const group = [];
                const queue = [{ x, y }];
                visited[y][x] = true;
                
                while (queue.length > 0) {
                    const { x: cx, y: cy } = queue.shift();
                    group.push({ x: cx, y: cy });
                    
                    // Check adjacent intersections
                    const directions = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
                    for (const dir of directions) {
                        const nx = cx + dir.x;
                        const ny = cy + dir.y;
                        
                        if (nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize && 
                            !visited[ny][nx] && testBoard[ny][nx] === color) {
                            visited[ny][nx] = true;
                            queue.push({ x: nx, y: ny });
                        }
                    }
                }
                
                return group;
            }
            
            // Check if a group has liberties
            function hasLiberties(testBoard, group) {
                for (const stone of group) {
                    const { x, y } = stone;
                    const directions = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
                    
                    for (const dir of directions) {
                        const nx = x + dir.x;
                        const ny = y + dir.y;
                        
                        if (nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize) {
                            if (testBoard[ny][nx] === null) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            // Simple AI move
            function makeAIMove() {
                if (gameOver) return;
                
                // Find all empty intersections
                const emptySpots = [];
                for (let y = 0; y < boardSize; y++) {
                    for (let x = 0; x < boardSize; x++) {
                        if (board[y][x] === null) {
                            emptySpots.push({ x, y });
                        }
                    }
                }
                
                if (emptySpots.length === 0) {
                    // No moves left
                    endGame();
                    return;
                }
                
                // Simple AI logic:
                // 1. Try to capture opponent stones
                // 2. Try to defend own groups in atari
                // 3. Random move otherwise
                
                // Check for captures first
                for (const spot of emptySpots) {
                    const { x, y } = spot;
                    const testBoard = board.map(row => [...row]);
                    testBoard[y][x] = 'white';
                    
                    const captured = checkCaptures(testBoard, 'black');
                    if (captured.length > 0) {
                        handleMove(x, y);
                        return;
                    }
                }
                
                // Check for defense (own groups with only one liberty)
                for (const spot of emptySpots) {
                    const { x, y } = spot;
                    const testBoard = board.map(row => [...row]);
                    testBoard[y][x] = 'white';
                    
                    // Check if this move saves any white group
                    const directions = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
                    for (const dir of directions) {
                        const nx = x + dir.x;
                        const ny = y + dir.y;
                        
                        if (nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize && 
                            board[ny][nx] === 'white') {
                            const group = findGroup(board, nx, ny);
                            if (!hasLiberties(board, group)) {
                                // This group is in atari, saving it would be good
                                handleMove(x, y);
                                return;
                            }
                        }
                    }
                }
                
                // If no captures or defense, make a random move (but not suicide)
                const shuffled = [...emptySpots].sort(() => 0.5 - Math.random());
                
                for (const spot of shuffled) {
                    const { x, y } = spot;
                    const testBoard = board.map(row => [...row]);
                    testBoard[y][x] = 'white';
                    
                    const group = findGroup(testBoard, x, y);
                    if (hasLiberties(testBoard, group)) {
                        handleMove(x, y);
                        return;
                    }
                }
                
                // If all moves are suicide, pass
                passTurn();
            }
            
            // Pass the turn
            function passTurn() {
                if (gameOver) return;
                
                showMessage(currentPlayer === 'black' ? "Black passed" : "White passed");
                
                // If two consecutive passes, end the game
                if (lastMove && lastMove.pass) {
                    endGame();
                    return;
                }
                
                lastMove = { pass: true };
                currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
                updateTurnDisplay();
                
                if (currentPlayer === 'white') {
                    setTimeout(makeAIMove, 800);
                }
            }
            
            // Resign the game
            function resign() {
                if (gameOver) return;
                
                const winner = currentPlayer === 'black' ? 'White' : 'Black';
                showMessage(`You resigned. ${winner} wins!`, true);
                gameOver = true;
                gameStatusElement.textContent = `Game over - ${winner} wins by resignation`;
                gameStatusElement.classList.remove('hidden', 'bg-yellow-100', 'text-yellow-800');
                gameStatusElement.classList.add('bg-red-100', 'text-red-800');
            }
            
            // End the game
            function endGame() {
                gameOver = true;
                
                // Simple scoring - count territory (very basic)
                let blackScore = blackCaptures;
                let whiteScore = whiteCaptures + 6.5; // Komi
                
                // Count empty intersections surrounded by one color
                const visited = Array(boardSize).fill().map(() => Array(boardSize).fill(false));
                
                for (let y = 0; y < boardSize; y++) {
                    for (let x = 0; x < boardSize; x++) {
                        if (board[y][x] === null && !visited[y][x]) {
                            const territory = findTerritory(x, y, visited);
                            const borderColor = getTerritoryBorderColor(territory);
                            
                            if (borderColor === 'black') blackScore += territory.length;
                            else if (borderColor === 'white') whiteScore += territory.length;
                        }
                    }
                }
                
                const winner = blackScore > whiteScore ? 'Black' : 'White';
                const scoreDiff = Math.abs(blackScore - whiteScore);
                
                showMessage(`Game over! ${winner} wins by ${scoreDiff.toFixed(1)} points`, true);
                gameStatusElement.textContent = `Game over - ${winner} wins by ${scoreDiff.toFixed(1)} points`;
                gameStatusElement.classList.remove('hidden', 'bg-yellow-100', 'text-yellow-800');
                gameStatusElement.classList.add('bg-green-100', 'text-green-800');
            }
            
            // Find contiguous empty intersections (territory)
            function findTerritory(x, y, visited) {
                const territory = [];
                const queue = [{ x, y }];
                visited[y][x] = true;
                
                while (queue.length > 0) {
                    const { x: cx, y: cy } = queue.shift();
                    territory.push({ x: cx, y: cy });
                    
                    const directions = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
                    for (const dir of directions) {
                        const nx = cx + dir.x;
                        const ny = cy + dir.y;
                        
                        if (nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize && 
                            board[ny][nx] === null && !visited[ny][nx]) {
                            visited[ny][nx] = true;
                            queue.push({ x: nx, y: ny });
                        }
                    }
                }
                
                return territory;
            }
            
            // Determine what color surrounds a territory
            function getTerritoryBorderColor(territory) {
                let blackBorder = false;
                let whiteBorder = false;
                
                for (const { x, y } of territory) {
                    const directions = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
                    for (const dir of directions) {
                        const nx = x + dir.x;
                        const ny = y + dir.y;
                        
                        if (nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize) {
                            if (board[ny][nx] === 'black') blackBorder = true;
                            else if (board[ny][nx] === 'white') whiteBorder = true;
                        }
                    }
                }
                
                if (blackBorder && !whiteBorder) return 'black';
                if (whiteBorder && !blackBorder) return 'white';
                return null; // Neutral or both colors border
            }
            
            // Show a message to the player
            function showMessage(message, persistent = false) {
                const msgElement = document.createElement('div');
                msgElement.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-md shadow-lg z-50';
                msgElement.textContent = message;
                document.body.appendChild(msgElement);
                
                if (!persistent) {
                    setTimeout(() => {
                        msgElement.classList.add('opacity-0', 'transition-opacity', 'duration-300');
                        setTimeout(() => msgElement.remove(), 300);
                    }, 2000);
                }
            }
            
            // Start a new game
            function newGame() {
                board = Array(boardSize).fill().map(() => Array(boardSize).fill(null));
                currentPlayer = 'black';
                lastMove = null;
                gameOver = false;
                blackCaptures = 0;
                whiteCaptures = 0;
                koProtection = null;
                
                blackCapturesElement.textContent = '0';
                whiteCapturesElement.textContent = '0';
                updateTurnDisplay();
                
                gameStatusElement.textContent = 'Game in progress';
                gameStatusElement.classList.remove('bg-red-100', 'text-red-800', 'bg-green-100', 'text-green-800');
                gameStatusElement.classList.add('bg-yellow-100', 'text-yellow-800');
                gameStatusElement.classList.remove('hidden');
                
                initializeBoard();
            }
            
            // Event listeners
            newGameButton.addEventListener('click', newGame);
            passTurnButton.addEventListener('click', passTurn);
            resignButton.addEventListener('click', resign);
            
            // Initialize the game
            newGame();
        });
    </script>
</body>
</html>